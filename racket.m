clear,clc;

%首先在极坐标下建立坐标
r=linspace(0.1,2.6,30);
theta=linspace(0,2*pi,30);
[R,Theta]=meshgrid(r,theta);

%在二维坐标下建立火箭整流罩网格
X_1=R.*cos(Theta);
Y_1=R.*sin(Theta);
Z_1=((18.5/2.6)^2*(2.60000000001^2*ones(30,30)-X_1.^2-Y_1.^2)).^(0.5)+80;
%surf(X_1,Y_1,Z_1);
%colormap(gray);
%grid on;
%hold on;

%构建火箭的侧面
z=linspace(0,80,50);
[Theta,Z_2]=meshgrid(theta,z);
X_2=2.6*cos(Theta);
Y_2=2.6*sin(Theta);
%surf(X_2,Y_2,Z_2);

%用三角网格构建火箭的尖端


%构建顶点矩阵
V=zeros(31,3);
V(1,3)=98.5;
V(2:31,1)=0.1*cos(theta)';
V(2:31,2)=0.1*sin(theta)';
V(2:31,3)=((18.5/2.6)^2*(2.6001^2*ones(30,1)-V(2:31,1).^2-V(2:31,2).^2)).^(0.5)+80;

%构建面矩阵
F=ones(30,3);
for i=1:29
    F(i,1:2)=[i+1,i+2];
end
F(30,1:2)=[31,2];

%绘制火箭尖端
%trisurf(F,V(:,1),V(:,2),V(:,3));

%title('火箭的三维网格划分');
%axis([-30 30 -30 30 0 110]);

%现在需要求得每个单位元的面积以及中点坐标，存储在矩阵中
S=zeros(2370,5);

%首先计算尖端单位元（共30个）
%中点坐标，以及单位元面积
for i=1:29
    S(i,1:3)=(V(F(i,1),:)+V(F(i,2),:)+V(F(i,3),:))/3;
    S(i,4)=triArea(V(F(i,1),:),V(F(i,2),:),V(F(i,3),:));
end

%再计算整流罩部分单位元
for j=1:29
    for k=1:29
        i=i+1;
        S(i,1:3)=([X_1(k,j),Y_1(k,j),Z_1(k,j)]+[X_1(k+1,j),Y_1(k+1,j),Z_1(k+1,j)]+[X_1(k,j+1),Y_1(k,j+1),Z_1(k,j+1)]+[X_1(k+1,j+1),Y_1(k+1,j+1),Z_1(k+1,j+1)])/4;
        S(i,4)=triArea([X_1(k,j),Y_1(k,j),Z_1(k,j)],[X_1(k+1,j),Y_1(k+1,j),Z_1(k+1,j)],[X_1(k,j+1),Y_1(k,j+1),Z_1(k,j+1)])+triArea([X_1(k+1,j),Y_1(k+1,j),Z_1(k+1,j)],[X_1(k,j+1),Y_1(k,j+1),Z_1(k,j+1)],[X_1(k+1,j+1),Y_1(k+1,j+1),Z_1(k+1,j+1)]);
    end
    %i=i+1;
    %S(i,1:3)=([X_1(30,j),Y_1(30,j),Z_1(30,j)]+[X_1(1,j),Y_1(1,j),Z_1(1,j)]+[X_1(30,j+1),Y_1(30,j+1),Z_1(30,j+1)]+[X_1(1,j+1),Y_1(1,j+1),Z_1(1,j+1)])/4;
    %S(i,4)=triArea([X_1(30,j),Y_1(30,j),Z_1(30,j)],[X_1(1,j),Y_1(1,j),Z_1(1,j)],[X_1(30,j+1),Y_1(30,j+1),Z_1(30,j+1)])+triArea([X_1(1,j),Y_1(1,j),Z_1(1,j)],[X_1(30,j+1),Y_1(30,j+1),Z_1(30,j+1)],[X_1(1,j+1),Y_1(1,j+1),Z_1(1,j+1)]);
end

%最后计算侧面单位元
for j=1:49
    for k=1:29
        i=i+1;
        S(i,1:3)=([X_2(j,k),Y_2(j,k),Z_2(j,k)]+[X_2(j+1,k),Y_2(j+1,k),Z_2(j+1,k)]+[X_2(j,k+1),Y_2(j,k+1),Z_2(j,k+1)]+[X_2(j+1,k+1),Y_2(j+1,k+1),Z_2(j+1,k+1)])/4;
        S(i,4)=norm([X_2(j+1,k),Y_2(j+1,k),Z_2(j+1,k)]-[X_2(j,k),Y_2(j,k),Z_2(j,k)])*norm([X_2(j,k+1),Y_2(j,k+1),Z_2(j,k+1)]-[X_2(j,k),Y_2(j,k),Z_2(j,k)]);
    end
    %i=i+1;
    %S(i,1:3)=([X_2(j,30),Y_2(j,30),Z_2(j,30)]+[X_2(j+1,30),Y_2(j+1,30),Z_2(j+1,30)]+[X_2(j,1),Y_2(j,1),Z_2(j,1)]+[X_2(j+1,1),Y_2(j+1,1),Z_2(j+1,1)])/4;
    %S(i,4)=norm([X_2(j+1,30),Y_2(j+1,30),Z_2(j+1,30)]-[X_2(j,30),Y_2(j,30),Z_2(j,30)])*norm([X_2(j,1),Y_2(j,1),Z_2(j,1)]-[X_2(j,30),Y_2(j,30),Z_2(j,30)]);
end

%建立方程组
e_0=8.854*10^-12;
A=zeros(2291);
for i=1:2291
    for j=1:2291
        if i~=j
            A(i,j)=S(j,4)/(4*pi*e_0*norm(S(i,1:3)-S(j,1:3)));
        else
            A(i,i)=(0.282*S(i,4)^(0.5))/e_0;
        end
    end
end
b=100*ones(2291,1);
S(1:2291,5)=A^(-1)*b;
E=S(:,5);
S(:,5)=log(10^11*S(:,5));

tri=delaunay(S(:,1),S(:,2),S(:,3));
trisurf(tri,S(:,1),S(:,2),S(:,3),S(:,5));
axis([-30 30 -30 30 0 110]);
shading interp;
colorbar;
title('火箭外表面电荷分布');